<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<link href="cs2_assignment.css" rel="stylesheet" type="text/css" />
<link rel="stylesheet" href="http://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css">
<title>CS2 Assignment 1: Introduction to C++</title>
<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script>
</head>

<body>
<div class="content">

<div class="author">Author: Ben Yuan</div>
<h1>CS2 Assignment 1: Introduction to C++</h1>
<h2>Due Tuesday, January 14, 2014, at 17:00 PST</h2>

<hr />

<h2>Introduction and course policies</h2>

<p>Welcome to CS2: Introduction to Programming Methods. In this course, you will learn about a collection of fundamental methods used in computer programming, including recursion, dynamic programming, graph algorithms, and other similar topics. You will be introduced to these at a theoretical level during the lectures; assignments will enable you to put the ideas you learn into practice, hopefully in an interesting manner. This course also functions as a survey course for a large portion of the advanced courses offered by the Computer Science option; topics covered in this course will be revisited in greater detail in higher-level courses.</p>

<p><div class="points easy">0</div>Off to the left side, you will see numbers. Such a number represents the point value of completing the objective denoted in the paragraph next to it. Most assignments have around 15 "main" points to earn, designated in green as demonstrated here; we expect all students to be able to complete these objectives.</p>

<p><div class="points hard">0</div>Higher-level points, where they exist, will be denoted in bolded red as demonstrated here. These higher-level objectives are intended for experienced students, and are by <span="hilite">no</span> means required for course completion. Don't spend too much time on these if you're having trouble!</p>

<h3>Lectures and recitations</h3>

<p>This course will have two lectures each week every Monday and Wednesday. Lectures will concentrate on the main ideas behind each week's topic, and will thus not present a large volume of code. Additionally, this course will have one recitation each week every Friday. Recitation will usually cover information directly related to the week's assignment.</p>

<h3>Homework due dates and extensions</h3>

<p>Homework is due on <span class="hilite">Tuesday afternoons at 17:00 Caltech time</span> unless specified otherwise. An ample number of office hours sections will be provided prior to each assignment due date. Office hours will be posted on the course web site when they are finalized.</p>

<p><span class="emph">If you're having trouble with the homework, or with any other part of the course, please come to office hours!</span> We've had students in the past fall into unfortunate situations that could have been avoided had they talked to a TA beforehand.</p>

<p>We recognize that not everyone will be able to meet all of the deadlines. Consequently, we permit a limited number of extensions to be taken. In brief, our extension policy works as follows:</p>
<ul>
<li>We permit <span class="hilite">two</span> extensions of <span class="hilite">48</span> hours each. These extensions may be taken consecutively (resulting in one 96-hour extension), or nonconsecutively (applied to two different assignments).</li>
<li>Extensions will be applied automatically to late work if available. There is no need to notify us that you are taking an extension, and doing so will not affect extension processing.</li>
<li>Due dates, both original and extended, are measured according to the time kept on the courses.caltech.edu website. These due dates are precise unless designated otherwise by a TA.</li>
<li>Homework submitted after the due date, extended by any available extensions, is considered late and will accrue a penalty. One-third of the grade that would have been assessed had the assignment been on time will be removed for every 24 hours (or <span class="hilite">any</span> fraction thereof) that the assignment is late. For instance, a grade of 12 would be reduced by 4 points for every block of 24 hours the assignment is late.</li>
<li>Grades for individual assignments are never reduced below zero points.</li>
<li>If your reason for being late is backed by a Health Center note or a letter from the Deans' office, penalties will be removed and extensions will be refunded as necessary.</li>
<li>In extraordinary circumstances outside the control of students, TAs, and professors, the professors and head TAs may remove penalties, refund extensions, and shift due dates independently of the other terms of this policy.</li>
</ul>
<p>Note that the above, while a mostly accurate summary, does not supersede the policy posted on the course web site.</p>

<h3>Homework and course grading</h3>

<p>Each assignment will be graded out of 20 points total (though there may be more than 20 earnable points). Most assignments will be submitted for grading to the Moodle website at courses.caltech.edu, with one or two graded via Bitbucket - we will not grade assignments sent by email. <span class="emph">You must be enrolled in this class according to the Moodle system for your work to be graded.</span></p>

<p>Many of the objectives for each assignment will be coding-based. We expect all submissions to at least compile on receipt. <span class="emph">If part of a submission consists of code that does not compile, the grading TA is not obligated to give any credit for that part.</span></p>

<p>The overall term will be graded out of 200 points. This is a pass-fail course; you must earn at least 120 points, and make a reasonable attempt at all assignments, to pass.</p>

<p>Observe that <span class="hilite">all assignments</span> must be attempted and submitted by the end of finals week for a passing grade to be assessed. E grades are not given. Grades of I will only be permitted in the usual extraordinary circumstances for which such a grade would be assessed (severe illness or other emergency, at the discretion of the Deans' office).</p>

<h3>Collaboration policy</h3>

<p>We have tried to make each homework as self-contained as possible. That said, we aren't going to be able to cover everything in the homework writeup, lectures, or recitation. Occasionally, you may need to consult external resources, and this is usually fine; in fact, we can recommend a handful of excellent resources for this purpose (check the course website). What we don't want you to do is look up answers when we want you to synthesize those answers yourself.</p>

<p>Additionally, CS2 is a programming-heavy course, and nothing can substitute for hands-on experience. While we do want you guys to help each other out in this process, we occasionally see students who overstep the boundary between "getting help with debugging" and "copying another student's code"; we <span class="emph">are</span> looking out for such cases, and to be honest, such students are only sabotaging their own learning experiences even if we don't catch them. We don't want you to become those students - we're much more interested in seeing you grow and develop properly.</p>

<p>To this end, our collaboration policy, in brief, is as follows:</p>
<ul>
    <li><span class="keyword">Anything you turn in for grading must fundamentally be your own work.</span></li>
    <li>When helping other students with debugging, keep your own code 50 feet away. Help students with your brain, not with your code.</li>
    <li>Sometimes you'll generate code while helping or being helped. That's fine. But if it's not your own code, then destroy it before continuing.</li>
    <li>External resources are cool. Getting outright answers from them is not. When in doubt, ask.</li>
</ul>
<p>Note that the above, while a mostly accurate summary, does not supersede the policy posted on the course web site.</p>

<h3>Platform requirements</h3>

<p>The assignments in this course are extremely coding-heavy and will be done in C++. Some of the advanced assignments deal with features and behavior that will differ across platforms, and the CS2 TA team does not have the resources to support every platform in existence. To this end:</p>
<p><span class="emph" style="color:red;">The only platforms we support in this class are 32-bit Linux and 64-bit Linux.</span></p>
<p>The TAs cannot provide support for Windows or Mac OS X and cannot guarantee that all assignments will even compile on those platforms. We encourage you to register for a CS cluster account so that you can use the machines in the Annenberg computer lab; if you are unable to provide your own Linux environment, then you will be <span class="hilite">required</span> to have a CS cluster account.</p>
<p>Be warned: you ignore this requirement at your own peril!</p>

<h3>Miscellany</h3>

<p>We have made some changes to the course from past years, and we hope that they will work out in your favor. If you have any feedback that you would like to offer, you are welcome to contact us at &lt;cs2-tas@ugcs.caltech.edu&gt;. This email reaches all current CS2 TAs and professors. Additionally, TQFR surveys are conducted at the end of each term; feel free to fill these out when they are made available. CS2 students come from a wide variety of talents, and we are interested in knowing if the course has been sufficiently instructive and challenging for you.</p>

<p>If you find that CS2 appears to be progressing too slowly and would like to 'test out', a placement test does exist; you may ask the professors or head TAs for a copy. <span class="emph">Observe that the placement test is <span class="hilite">much</span> more difficult than most of the content of the course</span>. Also observe that the difficulty of the course will increase as more advanced topics are covered. Passing the placement test exempts you from the CS2 requirement for graduation if you are in the Computer Science option, but does not grant you credit for the course.</p>

<hr />

<h2>Assignment background</h2>

<p>C++ is a multi-paradigm, statically typed, general-purpose compiled language, descended from the venerable C language, used for a variety of different applications and available on a plethora of different platforms. Since C++ compiles to native machine code, using C++ can, in the right hands, enable the creation of applications that outperform their interpreted-language counterparts by impressively wide margins. While C++ does not have as extensive a standard library as higher-level languages like Python or Java, third-party libraries have been developed for almost every imaginable purpose, and existing C libraries can be integrated into C++ programs with minimal effort.</p>

<p>As a direct descendant of C, C++ provides no automatic memory management by default: while some automatic garbage collection primitives do exist, their use will not be covered in this course. Hence, the burden is largely on the programmer to ensure that resources are properly cleaned up after use. Additionally, as a direct descendant of C, C++ provides <span class="keyword">pointers</span>, which are used to <span class="emph">reference</span> data elsewhere in memory, as well as <span class="keyword">pointer arithmetic</span>, which allows pointers to be reassigned to point to adjacent data in memory.</p>

<p>While C++ is a multi-paradigm language, one of its most well-known features is its support for <span class="keyword">object-oriented programming</span>. In this paradigm, an application is described by objects and their interactions with each other. Objects consist of sets of data fields and member functions describing the properties and behavior of each object type.</p>

<p>Objects are sorted into <span class="keyword">classes</span>. Each class describes a different type of object, each with its own properties and behaviors. Classes can be <span class="keyword">instantiated</span>; that is, objects of a particular class can be created. Each object is mostly independent of the other objects in the program, even objects of the same class; however, objects of the same class will behave alike.</p>

<h2>Prerequisites</h2>

<p>This assignment relies primarily on having a working development environment.</p>
 
<p>Ask a TA if you need help setting up your environment.</p>

<hr />

<h2>Assignment (20 points)</h2>

<p>When you are finished with this assignment, please archive the assignment folder in an archive file named <span class="code">USERNAME-cs2-week1.tar.gz</span> or <span class="code">USERNAME-cs2-week1.zip</span>, and upload it to Moodle.</p>

<h3>Part 0: Getting started.</h3>

<h4>New Tools: g++</h4>

<p>C++ is a compiled language, and the standard compiler we'll use is g++. g++ is part of the well-respected GCC (GNU Compiler Collection) suite; its purpose is to convert C++ code into native code suitable for a target platform. This first exercise will show you how to invoke the g++ compiler by hand.</p>

<p>Here's a complete C++ program:</p>

<div class="codebox">
    <div class="header">hello.cpp</div>
    <pre><code class="prettyprint">/******
* 
* @file
* @author The CS2 TA Team &lt;cs2-tas@ugcs.caltech.edu&gt;
* @date 2014
* @copyright This code is in the public domain.
*
* @brief The canonical Hello World program in C++.
*
* This program prints out "Hello, world!" to standard output.
*
******/

/*
This, like the preceding block, is a block (multi-line) comment.
It is ignored by the compiler.
*/

// This is a single-line comment.
// The // marks everything until the end of the line as a comment.

// First we include any 'external' libraries.
// In this case we only need the standard I/O functions inherited from C.
#include &lt;cstdio&gt;

/**
* @brief Prints "Hello, world!" and exits.
*
* This program prints out "Hello, world!" to the terminal. It is the C++
* version of the canonical "Hello World" example, used to demonstrate
* a few of the most basic constructs of a programming language: the
* structure of a minimal program, as well as the syntax required for
* output to the terminal.
*
* Even the simplest of C++ programs, like this one, has a main() function.
* This function is invoked first, by convention, and under normal operation
* returns last.
*/
int main(int argc, char ** argv)
{
    // Print to the terminal.
    // printf() allows you to print arbitrary static strings to standard output.
    printf("Hello, world!\n");
    
    // By convention, main() always returns 0 for successful execution.
    return 0;
}</code></pre>
</div>

<p>Copy the contents of that code into a new file called 'hello.cpp'. Then open a terminal and run the following commands:</p>

<div class="codebox">
    <div class="header">Terminal</div>
    <pre><code>cd /path/to/cs2/week1
g++ -c -g -Wall --std=c++0x -o hello.o hello.cpp
g++ -o hello hello.o
./hello</code></pre>
</div>

<p>In brief, each line after <span class="code">cd /path/to/cs2/week1</span> does the following:</p>

<ul>
    <li>Compiles the <span class="keyword">source file</span> <span class="code">hello.cpp</span> into an <span class="keyword">object file</span> <span class="code">hello.o</span>.</li>
    <li>Links the <span class="code">hello.o</span> object file with the C++ Standard Library, producing a <span class="keyword">executable file</span> <span class="code">hello</span>. (Executable files may also be called <span class="keyword">binary files</span> by some sources; we may use this alternative term later on.)</li>
    <li>Runs the <span class="code">hello</span> executable.</li>
</ul>

<p>You should hopefully see the following output afterwards:</p>

<div class="codebox">
    <div class="header">Terminal Output</div>
    <pre><code>Hello, world!</code></pre>
</div>

<p><div class="points easy">1</div>Include the generated executable with your archive submission.</p>

<h4>New Concepts: Formatted Text Output</h4>

<p>It is often useful to be able to print out arbitrary output to the terminal. This is a good first-line debugging tool - being able to display intermediate computation steps and monitor program flow without a debugger is useful for verifying program correctness in a non-labor-intensive manner.</p>

<p>The C++ Standard Library inherits the formatted output features provided by C, including the <span class="code">printf()</span> function. <span class="code">printf()</span> is a flexible function that can print arbitrary text to standard output, and additionally provides variable substitution and formatting.</p>

<p><span class="code">printf()</span> has the following function signature:</p>

<div class="codebox">
    <pre><code class="prettyprint">int printf(const char * format, ...);</code></pre>
</div>

<p>You have seen a simple invocation of this function already in the previous example. As mentioned, though, <span class="code">printf()</span> also allows arbitrary substitution of variables as dictated by the format string. Any token beginning with % has a special meaning: it tells <span class="code">printf()</span> to attempt to consume an argument after the format string, convert that argument's value into the correct format, and output the resulting formatted value. (If you need a literal %, use %% instead.)</p>

<p>For example:</p>

<div class="codebox">
    <div class="header">printf() example 1</div>
    <pre><code class="prettyprint">// Here we're declaring and initializing some variables.
// Notice that every variable in C++ has a data type.
// Variables can only store values of the type with which they are declared.

int foo; // This is a signed integer value.
         // Note that we have not initialized its value!
         // Until and unless we do, its value is *indeterminate*;
         // it could be 0, or -1, or 9001, or ...
double bar = 5.0; // This is a double-precision floating-point value.
                  // Notice we have initialized its value to 5.0.
const char * fish = "orange"; // This is a C-style string constant.
                              // Notice the 'const' keyword.
                              // You'll learn more about the * later.
unsigned int protons = 3000000001; // This is an unsigned integer value.
...
// %d is the format token for a signed integer.
printf("foo: %d\n", foo);
// %f is the format token for a floating-point value.
printf("bar: %f\n", bar);
// %s is the format token for a C-style string.
printf("fish: %s\n", fish);
// %u is the format token for an unsigned integer.
// %x is the format token for an unsigned integer, converted to hex.
// Note that using %d with an unsigned integer can obscure the true value
// in the case where the integer is large.
printf("protons (wrong): %d\n", protons);
printf("protons (right): %u\n", protons);
printf("protons (hex): %x\n", protons);</code></pre>
</div>

<p>Without compiling this example, try to guess what you might see. If you want, you can verify your guesses.</p>

<p>Now open up <span class="code">debugging1.cpp</span> and have a look inside.</p>

<p><div class="points easy">1</div>Add some <span class="code">printf()</span> statements to the code that display what's going on at each step of the computation; additionally, print out the result of the computation. Do you notice anything? What happens if you change a and b? Can you explain what this code is doing, and why it does what it does?</p>

<p>Include the <span class="code">debugging1.cpp</span> file with your archive submission. Place your short answers inside a block comment after the file header, but before the first <span class="code">#include</span> statement.</p>


<h4>New Tools: gdb</h4>

<p><span class="code">printf()</span> is a remarkably useful tool, but it struggles to handle more challenging examples. Sometimes, we need to more methodically inspect the workings of our code in order to track down a problem.</p>

<p>Open up <span class="code">debugging2.cpp</span> and have a look at the code. This code is <span class="emph">supposed</span> to be an implementation of the binary long-division algorithm. Try compiling and running it. You'll find that it doesn't actually work.</p>

<p>The more experienced and careful readers among you may already have spotted the errors. Let's suppose you haven't. Make sure you used the <span class="code">-g</span> flag when compiling; otherwise the next steps won't work properly.</p>

<p>Let's open up the GDB debugger and use it to figure out what's really going on. (Your terminal output may vary slightly depending on version.)</p>

<div class="codebox">
    <div class="header">Terminal (input bolded)</div>
    <pre><code>$ <b>gdb ./debugging2</b>
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
For bug reporting instructions, please see:
&lt;http://bugs.launchpad.net/gdb-linaro/&gt;...
Reading symbols from /path/to/debugging2...done.
(gdb) </code></pre>
</div>

<p>To exit the debugger at any time, enter <span class="code">quit</span> into the GDB prompt.</p>

<p>At this point we can just run the program by entering <span class="code">run</span>, but that would tell us little on its own. We should be a little more methodical. We can set a <span class="keyword">breakpoint</span>, which tells GDB to stop when it reaches the corresponding line of code:</p>

<div class="codebox">
    <div class="header">Terminal (input bolded)</div>
    <pre><code>(gdb) <b>break debugging2.cpp:74</b>
Breakpoint 1 at 0x400557: file debugging2.cpp, line 74.
(gdb) <b>run</b>
Starting program: /path/to/debugging2 

Breakpoint 1, main (argc=1, argv=0x7fffffffe238) at debugging2.cpp:74
74	    printf("%u\n", divide(15625, 37)); // should print 422
(gdb) 
</code></pre>
</div>

<p>We have a few ways of advancing program flow at this point:</p>

<ul><li><span class="code">step</span> (<span class="code">s</span>): advances the program by a single line of code, tracing into function calls</li>
<li><span class="code">next</span> (<span class="code">n</span>): advances the program by a single line of code, without entering any functions</li>
<li><span class="code">finish</span> (<span class="code">fin</span>): advances the program until the current function returns</li>
<li><span class="code">continue</span> (<span class="code">c</span>): advances the program until the next breakpoint or program termination</li>
</ul>

<p>Let's trace into the <span class="code">divide()</span> function call.</p>

<div class="codebox">
    <div class="header">Terminal (input bolded)</div>
    <pre><code>(gdb) <b>step</b>
divide (a=15625, b=37) at debugging2.cpp:31
31	    unsigned int x = 0, y = 0, z = sizeof(a) * 8;
(gdb) </code></pre>
</div>

<p>Let's get our bearings (your output may vary):</p>

<div class="codebox">
    <div class="header">Terminal (input bolded)</div>
    <pre><code>(gdb) <b>backtrace</b>
#0  divide (a=15625, b=37) at debugging2.cpp:31
#1  0x0000000000400566 in main (argc=1, argv=0x7fffffffe238)
    at debugging2.cpp:74
(gdb) <b>print x</b>
$2 = 0
(gdb) <b>print y</b>
$3 = 4195712
(gdb) <b>print a</b>
$4 = 15625
(gdb) <b>print b</b>
$5 = 37
(gdb) <b>print a / b</b>
$6 = 422
</code></pre>
</div>

<p>Note a couple of things:</p>

<ul><li>Notice that either or both of <span class="code">x</span> and <span class="code">y</span> may not in fact be equal to zero at this point. The source code line displayed by gdb is always the line of code that will be executed next, for example by a <span class="code">next</span> command. Additionally, recall that variables in C++ are not initialized unless and until you assign them an initial value.</li>
<li>The <span class="code">backtrace</span> command prints the call stack. That is, it lists all of the functions calls that have been made that have yet to return, most recent first.</li>
<li>The <span class="code">print</span> command can print the results of essentially arbitrarily complex expressions, even those containing function calls. Take caution when calling functions with side effects in this manner.</li></ul>

<p>After a step, we see this - our variables are now initialized:</p>

<div class="codebox">
    <div class="header">Terminal (input bolded)</div>
    <pre><code>(gdb) <b>step</b>
33	    while(z != 0)
(gdb) <b>print x</b>
$7 = 0
(gdb) <b>print y</b>
$8 = 0
(gdb) <b>print a</b>
$9 = 15625
(gdb) <b>print b</b>
$10 = 37
(gdb) 
</code></pre>
</div>

<p><div class="points easy">1</div>At this point you should have enough tools to figure out what's up with this example, if you haven't already. Fix the bug or bugs. Leave the fixed code in <span class="code">debugging2.cpp</span> and include it with your archive submission.</p>

<h4>New Concepts: Writing Functions, Function Calls, Function Contracts</h4>

<p>You've already seen functions being used in the previous example, and hopefully the general concept is not completely alien to you. In brief, a <span class="keyword">function</span> is a piece of code that may be invoked from elsewhere in the program; when invoked, given zero or more arguments, the function performs some useful work, possibly having side effects, and then may or may not return a value.</p>

<p>Every function in C++, just like any variable, has a type. The type of a function is determined by the type of its arguments as well as the type of its return value; these are stated when the function is first declared. For instance,</p>

<pre><code class="prettyprint">double qfsolve(double a, double b, double c)</code></pre>

<p>would describe a function that takes three double-precision floating-point arguments and returns a double-precision floating-point value.</p>

<p>Functions need not return a value; in that case, their return type would be <span class="code">void</span>.</p>

<p>It may not always be evident at first glance what a function is supposed to do. Any well-documented project will have <span class="keyword">function headers</span> describing the salient properties of a function in ordinary language. A good function header lists, at minimum:</p>

<ul><li>the main purpose of the function</li>
<li>the function arguments and their respective meanings</li>
<li>the meaning of the function return value, if any</li>
<li>any side effects caused by calling the function</li></ul>

<p>Here's an example of a good function header:</p>

<pre><code class="prettyprint">/**
 * @brief Solves the given quadratic equation.
 * 
 * This function, given real coefficients A, B, C to the equation
 * A*x*x + B*x + C = 0, returns the real part of a solution to the
 * equation thus defined. Where two real solutions exist, the one 
 * closer to positive infinity is chosen.
 * 
 * @param a the quadratic coefficient.
 * @param b the linear coefficient.
 * @param c the constant coefficient.
 * 
 * @return the real part of a solution to the defined quadratic equation,
 *         as described.
 */</code></pre>
 
<p><div class="points easy">1</div>In a new file <span class="code">qfsolve.cpp</span>, define a function <span class="code">qfsolve()</span> that fulfills the given function header. Prepend the header to the function definition. Additionally, write a <span class="code">main()</span> function that tests your <span class="code">qfsolve()</span> function; i.e. come up with a collection of five or six test cases, and invoke <span class="code">qfsolve()</span> for each case, displaying the inputs and output. Include the source file with your archive submission.</p>

<p>You will probably need a <span class="code">sqrt()</span> function. The C++ Standard Library defines one; you should <span class="code">#include &lt;cmath&gt;</span> so you have access to it.</p>

<h4>New Concepts: Static Arrays</h4>

<p>There is only so much computation we can do with scalar quantities; many interesting problems require some sort of vector or sequence type. The static array, inherited from C++, is the simplest of these.</p>

<p>An array is nothing more than a block of memory allocated for the purpose. We declare and use arrays like this:</p>

<pre><code class="prettyprint">// declare an integer array of size 20
int foo[20];
// set every element to 0
for(int i = 0; i &lt; 20; i++)
{
    foo[i] = 0;
}
// set some arbitrarily chosen element 
foo[7] = 42;

// initializer list syntax
// we can explicitly specify initial values here
int bar[10] = {3, 1, 4, 1, 5, 9, 2, 6};</code></pre>

<p>Arrays have the following properties:</p>

<ul><li>Arrays support constant-time random access. That is, any element can be accessed by index in the same amount of time as any other element, even out of order.</li>
<li>Arrays have a fixed size. That is, once declared, they cannot be directly resized.</li>
<li>Every element of an array is of the same type. Types cannot be mixed in an array.</li>
<li>Arrays have no range checking, and in fact no reliable way to query their own length, requiring that lengths be hard-coded or otherwise recorded.</li></ul>

<p>We can also pass arrays as arguments to functions. We'll learn an alternative syntax for this later, but for now we'll use this syntax:</p>

<pre><code class="prettyprint">/**
* @brief Prints out the elements of an integer array.
* 
* @param arr the array to print
* @param n   the number of elements in the array
*/
void array_print(int arr[], int n)
{
    for(int i = 0; i &lt; n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}</code></pre>

<p>We mark an argument as an array with empty square brackets, e.g. <span style="code">arr[]</span>. Since arrays have no inherent length, we must pass the array length as an additional argument.</p>

<p><div class="points easy">1</div>In the file <span class="code">arrays1.cpp</span>, write some functions to do the following:</p>

<ul><li>Given an array of integers, finds its maximum value.</li>
<li>Given an array of integers, finds its arithmetic mean.</li>
<li>Given an array of integers, fills it with an ascending sequence.</li></ul>

<p>Using the code already there, demonstrate that your functions work. Include your modified code with your archive submission.</p>

<h3>Part 0 again: What (not) to do.</h3>

<h4>Remarks on code cleanliness</h4>

<p>Writing clean, readable, well-organized code makes everyone's lives easier. It makes your life better, since such code is more straightforward to maintain; it makes your peers' lives better, as such code is easier to inspect and understand; it makes your life better six months from now, when you'll have forgotten everything about this code and need to read it all again.</p>

<p>Sometimes we receive code that adheres to a high standard of maintainability, and we are happy. Sometimes we receive code and discover we are not so lucky:</p>

<pre><code class="prettyprint">int f(int a,int b){int x=a,y=b,z=1,q=2,r=3;while(x^y){if(x>y){q=x+(~y+1);x=q;}else{r=y-x;y=r;}}z=x;return z;}</code></pre>

<p><div class="points easy">1</div>In a new file <span class="code">cleaned.cpp</span>, write and test a cleaned-up version of the code above. Among other tasks, you should:</p>

<ul><li>Give the function a sensible name and a sensible function header.</li>
<li>Eliminate redundant variables.</li>
<li>If appropriate, give variables sensible names.</li>
<li>Replace complicated or nonstandard expressions with simpler ones, where possible.</li>
<li>Use sensible spacing and indentation. Just because C++ doesn't care about whitespace doesn't mean you shouldn't.</li></ul>

<p>Include the source file with your archive submission.</p>


<h3>Part 1: Structured data, memory, and pointers.</h3>

<h4>New Concepts: The <span class="code">struct</span></h4>

<p>C++ is a strongly typed language; essentially, this means that any variable name defined in a C++ program has a rigidly defined type associated with it, restricting what kind of data that variable can store. C++ has a variety of built-in data types, mostly numeric types like <span class="code">int</span>, <span class="code">unsigned int</span> and <span class="code">double</span>.</p>

<p>These data types, on their own, are capable only of representing the most basic data; more complex constructs, like matrices and data records, can only be adequately represented by compositions of basic variables. To make this task easier, C++ provides the <span class="code">struct</span>: a programming construct allowing composite data types to be defined and used.</p>

<p>For example, if we wanted to define a data type representing a two-dimensional vector, here's one way we could do it:</p>

<div class="codebox">
    <div class="header">structs0.cpp</div>    
    <pre><code class="prettyprint">/**
 * @file
 * @author The CS2 TA Team &lt;cs2-tas@ugcs.caltech.edu&gt;
 * @date 2014
 * @copyright This code is in the public domain.
 *
 * @brief A struct usage example.
 */

#include &lt;cstdio&gt;
#include &lt;cmath&gt;

/**
 * @brief Defines a simple two-dimensional vector.
 */
struct vector2d
{
    double x; /**&lt; the horizontal component */
    double y; /**&lt; the vertical component */
}; // do NOT omit the semicolon here! it's required

/**
 * @brief Basic use of the 2D vector struct we defined earlier.
 */
int main(int argc, char ** argv)
{
    // set up and initialize a new vector
    vector2d a;
    // Notice the . notation below.
    // The notation "foo.bar" refers to the member 'bar' in the object 'foo'.
    a.x = 3;
    a.y = 4;

    // calculate and print a magnitude
    printf("norm([%f %f]) = %f\n", a.x, a.y, sqrt(a.x * a.x + a.y * a.y));
    
    return 0;
}

</code></pre>
</div>

<p>Structs can contain other structs as members. However, it is more common to see structs containing pointers to other structs. This feature enables the creation of more complex data structures, like linked lists, trees, and directed graphs, which will be explored in somewhat greater detail during Labs 3 and 5.</p>

<p>The member variables of a given instance of a struct are placed mostly adjacent to each other. However, compilers will usually insert padding between fields so that the fields are aligned to certain byte boundaries. Usually, compilers targeting 32-bit systems try to align struct members to 4-byte boundaries, since 4 bytes is the most efficiently accessed data size on such platforms.</p>

<p></p>

<h4>New Concepts: Pointers</h4>

<p>While a computer program is executing, it needs a place to store information about its immediate state in a readily available place. This place is called <span class="keyword">memory</span>. This term, in particular, most commonly refers to the <span class="keyword">random-access memory</span>, or <span class="keyword">RAM</span>, present in almost all general-purpose computers available today.</p>

<p>We typically measure memory size in <span class="keyword">bytes</span>. One byte is composed of eight bits; each bit can represent one of two values (0 or 1), and consequently each byte can represent any one of 256 possible values.</p>

<p>Whenever we define a variable, the compiler allocates some memory to store its value. This bit of memory has an <span class="keyword">address</span>, a serial number identifying its location. Supposing we define a variable <span class="code">i</span>; then its address is denoted by <span class="code">&amp;i</span>, where <span class="code">&amp;</span> is the <span class="keyword">address-of operator</span>.</p>

<p>Memory addresses don't do us any good unless we can store them. This is where pointers come in. A pointer is a variable that stores a memory address. Pointers are declared like this:</p>

<pre><code class="prettyprint">// this is a pointer to integer
int * foo;</code></pre>

<p>Notice the <span class="code">*</span>, which in this context marks <span class="code">foo</span> as a pointer.</p>

<p>Pointers can then be populated with memory addresses, like so:</p>

<pre><code class="prettyprint">int bar;
// set foo to point to bar
foo = &amp;bar;
// now foo contains the address of bar
// which could be something like 0xff235600</code></pre>

<p>Once a pointer is populated with a memory address, it may be <span class="keyword">dereferenced</span> to access or modify the value to which it is pointing, like so:</p>

<pre><code class="prettyprint">bar = 10;
// *foo : dereference foo
printf("%d", *foo); // prints 10
*foo = 12;          // bar now contains 12
printf("%d", bar);  // prints 12</code></pre>

<p>Pointers also support <span class="keyword">pointer arithmetic</span>, which allows adjacent memory to be accessed. For instance:</p>

<pre><code class="prettyprint">int arr[5] = {3, 1, 4, 1, 5};
int * p = &amp;arr[0];
// *p == 3
p++; // increment the POINTER
// p == &amp;arr[1], *p == 1
printf("%d\n", *(p+3)); // prints 5</code></pre>

<p>Be aware that pointer arithmetic adds and subtracts by multiples of the pointer base type; that is, adding 1 to an <span class="code">int</span> pointer really adds 4 bytes (<span class="code">sizeof(int)</span>) to the memory address contained within.</p>

<p><div class="points easy">2</div>Notice also that equivalence exists between array and pointer notation: anything you can do with the array notation, you can do with pointer operations. Try this out: redo the <span class="code">arrays1.cpp</span> exercise in <span class="code">arrays2.cpp</span> without ever using the array notation.</p>

<h4>Exercise: memory exploits for fun and profit</h4>

<p>Remember how we said struct members are held basically contiguous in memory? Let's do a little exercise to run that point home.</p>

<p>In the <span class="code">pointers</span> folder you'll see <span class="code">blackbox.h</span> and a couple of .o files. These define a "black box". You know the following about this box:</p>

<ul><li>The box must be initialized (by <span class="code">init()</span> in <span class="code">blackbox.h</span>) before it can be used.</li>
<li>The box contains a character string.</li>
<li>The box can print this string to the screen (by <span class="code">print_contents()</span>).</li>
<li>The box will only print this string if the correct password was provided (by <span class="code">authenticate()</span>).</li>
<li>The box keeps track of this state using a data structure. The only thing you know about this structure is that the password is kept, in plain text, starting at an offset of 128 bytes from the structure start, and is at most 15 characters long.</li>
<li>Someone has added a backdoor to the box that exposes the state structure's address in memory.</li></ul>

<p><div class="points easy">2</div>In a new file <span class="code">exploit.cpp</span>, write some code that forces the black box to print its contents via a successful call to <span class="code">print_contents()</span>. It's not enough to extract the string directly and print it out - that would be too easy. You can build your example like this, on a 64-bit system, from the <span class="code">pointers</span> directory:</p>

<div class="codebox">
    <pre><code>make exploit64
</code></pre>
</div>

<p>On a 32-bit system, instead type:</p>

<div class="codebox">
    <pre><code>make exploit32
</code></pre>
</div>

<p>The black box is not a very secure system (in fact, it's full of holes), so there's more than one way to accomplish this task. Include your code with your archive submission.</p>

<p>You will need to <span class="code">#include "blackbox.h"</span> to use the black box functions.</p>

<h3>Part 2: memory management is "easy".</h3>

<h4>New Concepts: Dynamic Memory Allocation</h4>

<p>As our computing requirements increase, we begin to realize a need to allocate <span class="emph">arbitrary</span> amounts of memory at runtime, without foreknowledge of how much we need. C++ provides a feature known as <span class="keyword">dynamic memory allocation</span> that allows us to request memory as we need it.</p>

<p>When we declare a variable in function scope, its memory resides in an area of memory known as the <span class="keyword">stack</span>. Stack memory is cleaned up automatically when it goes out of scope. Unfortunately, stack space is limited, usually not more than a few megabytes, and so is not suitable for large amounts of data.</p>

<p>Dynamic memory allocation allows memory to be requested from a different area, known as the <span class="keyword">heap</span>. Heap memory is much larger (several gigabytes on modern systems). However, heap memory is not automatically managed by C++; the programmer must request and release heap memory as needed.</p>

<p>While it is possible to request singletons of primitive data types, this is usually not done; heap allocation is usually reserved for struct instances, class instances, and arrays.</p>

<p>Here's how we request and release memory from the heap:</p>

<pre><code class="prettyprint">struct Foo { ... };

// instantiate a new Foo
Foo * f = new Foo;

// instantiate an array of ints
size_t len = 16777216;
int * arr = new int[len];

// ... do some stuff ...

// free the Foo instance
delete f;

// free the array; notice square brackets
delete[] arr;

</code></pre>

<p><div class="points easy">2</div>Go ahead and copy the work you did in <span class="code">arrays2.cpp</span> into a new file <span class="code">arrays3.cpp</span>, but change the test code to allocate arrays of exactly the correct size rather than of a fixed size. Test your functions on some very large dynamically allocated arrays (at least 1 million integers); for fun, see how large you can make your test arrays without running out of memory.</p>

<h4>Debugging: Segmentation Faults</h4>

<p>A <span class="keyword">segmentation fault</span> happens when we try to dereference a pointer pointing outside accessible memory. A segmentation fault is one kind of problem that can happen with invalid pointers. Pointers can go invalid in a few ways, including but not limited to:</p>

<ul><li>Pointer was never initialized.</li>
<li>Pointer was set to 0 or NULL.</li>
<li>Pointer was pointing to an object that was deleted.</li>
<li>Pointer arithmetic sent the pointer outside accessible memory.</li></ul>

<p>For instance, this code would cause a segfault, since we're trying to dereference a null pointer:</p>

<pre><code class="prettyprint">int * z = 0; // initialize pointer
// ... do some other stuff forgetting about z ...
printf("z points to %d", *z); // null pointer dereference!
</code></pre>

<h3>Part 3: Basic object-oriented design.</h3>

<h4>New Tools: Classes</h4>

<p>C++ extends the struct mechanism inherited from C by introducing the notion of <span class="keyword">classes</span>. Classes provide member variables, member functions, abstraction, inheritance, and polymorphism, among other features.</p>

<p>Here's an example of a partial class definition along with some instantiations:</p>

<pre><code class="prettyprint">// vector2.hpp
    
/**
* @brief A two-dimensional vector class.
*/
class Vector2
{
private:
    double x; /**&lt; the horizontal component **/
    double y; /**&lt; the vertical component **/
public:
    Vector2();
    Vector2(double m, double n);
    ~Vector2();
    double GetX();
    double GetY();
    void SetX(double val);
    void SetY(double val);
    
    double GetLength();
};

// vector2.cpp

/**
* @brief Constructs a new zero-length vector.
*/
Vector2::Vector2()
{
    x = 0;
    y = 0;
}

/**
* @brief Constructs a new vector with known elements.
*/
Vector2::Vector2(double m, double n)
{
    x = m;
    y = n;
}

/**
* @brief Gets the x-coordinate of this vector.
*/
double Vector2::GetX()
{
    return x;
}

/**
* @brief Sets the x-coordinate of this vector.
*/
void Vector2::SetX(double val)
{
    x = val;
}

// ... and so forth ...

// let's instantiate some vectors
Vector2 a; // zero vector
Vector2 b(3, 5); // vector [3, 5]
Vector2 c = Vector2(6, 8); // vector [6, 8]

// now some dynamically allocated vectors
Vector2 * m = new Vector2(); // zero vector
Vector2 * n = new Vector2(8, 6); // vector [8, 6]
</code></pre>

<p>Just like structs, classes can have member variables. Unlike structs in C, though, classes in C++ can also have member functions, which are functions that implicitly take a class instance as an argument. We can specify visibility for these variables:</p>

<ul><li>public: accessible everywhere</li>
<li>protected: accessible from class and derived classes only</li>
<li>private: accessible from class only</li></ul>

<p>The purpose of specifying visibility is to facilitate <span class="keyword">abstraction</span>. Consider the case, for instance, where we are providing a module for someone else to use. If we need to expose our module's internals to its users, then any major changes to how we handle data internally will cause huge problems for the people using it. However, if we hide the internals, and provide consistent <span class="keyword">APIs</span> in the form of function calls, then changes to the module can occur independently of the module's users.</p>

<p>Every C++ class has two special kinds of functions: <span class="keyword">constructors</span> and <span class="keyword">destructors</span>. Constructors are called when an object is instantiated, and destructors are called when an object is deleted or goes out of scope. Constructors are usually used to initialize member variables either to known values or to values passed in as constructor arguments; their function name is equal to the class name, and they return nothing (not even <span class="code">void</span>!!). Destructors are usually used to clean up any memory or other resources held by an object; their function name is equal to the class name prefixed by a tilde, and, like constructors, they also return nothing at all.</p>

<p>C++ allows classes to derive from base classes, inheriting their public and protected members, through the <span class="keyword">inheritance</span> mechanism; pointers to derived classes can be transparently cast to pointers to base classes. Additionally, C++ allows member functions to be marked as <span class="keyword">virtual</span> functions, allowing their behavior to be overriden by derived classes; through the <span class="keyword">polymorphism</span> mechanism, pointers to base classes, when used to call virtual functions, will transparently call the correct version of the function depending on what class of object is actually being pointed to.</p>

<h4>Exercise: Tic-Tac-Toe</h4>

<p>In this exercise, you'll be programming a simple game from scratch; namely, a game of tic-tac-toe. The catch is, you'll be doing it in an object-oriented fashion.</p>

<p>For this exercise, you'll be working in the <span class="code">tictactoe</span> directory. You'll notice we've put some empty files there for you, as well as a Makefile. You'll populate, at least, these empty files, and possibly more depending on how you decide to do your architecture.</p>

<p>A minimal, <span class="emph">incomplete</span> architecture outline for this exercise might look like this:</p>

<ul>
    <li>a Board class, representing the game board</li>
    <ul>
        <li>member variables</li>
        <ul>
            <li>squares - stores occupancy data for this board</li>
        </ul>
        <li>member functions</li>
        <ul>
            <li>Query() - given board coordinates, return a square state (unoccupied, X, O)</li>
            <li>Place() - given board coordinates and a piece type, places a game piece onto the board</li>
            <li>CheckWin() - returns which player won, if any</li>
            <li>CheckDraw() - returns whether the game has ended in a draw</li>
        </ul>
    </ul>
    <li>a Game class, holding the game state</li>
    <ul>
        <li>member variables</li>
        <ul>
            <li>board - the game board instance for this game</li>
            <li>turn - whose turn is it to play</li>
        </ul>
        <li>member functions</li>
        <ul>
            <li>Run() - sets up and plays a single session of Tic-Tac-Toe</li>
        </ul>
    </ul>
</ul>

<p>You are free to make your class hierarchy more elaborate than this if you like, but you should have at least these two classes. The <span class="code">main()</span> function should invoke your <span class="code">Game::Run()</span> function as part of its operation.</p>

<p>To take user input, you can use the <span class="code">scanf()</span> function, which reads in input from the terminal and stores it in variables depending on a provided format string. For instance, to read in an integer value:</p>

<pre><code class="prettyprint">int choice;

printf("Enter your answer: ");
scanf("%d", &amp;choice); // notice that scanf() wants addresses!
</code></pre>

<p><div class="points easy">3</div>Your implementation should satisfy the following specifications:</p>

<ul><li>This is a two-player game played on a 3x3 board.</li>
<li>Input and output should be handled from the command prompt. For this assignment, you may assume all input is valid, though this is generally a dangerous assumption to make.</li>
<li>Two humans should be able to play interactively, in a "hot seat" mode. That is, both players use the same computer, while taking turns.</li>
<li>The X player should always go first.</li>
<li>Play should alternate between players, with each player placing one symbol in an empty square per turn.</li>
<li>The first player to place three symbols in a row wins.</li></ul>

<p>To achieve full credit, your source code must be completely documented. That is:</p>

<ul><li>Every function should receive a function header. At an absolute minimum, each function header should contain a brief English description of the function in question, as well as descriptions of any parameters, return values, and side effects.</li>
<li>Every classes should receive a class header. At an absolute minimum, each class header should contain a brief English description of the class in question: what it is, and what its purpose is.</li>
<li>Any non-trivial code should be annotated with descriptions of what is happening. These should complement and explain the code, <span class="emph">not</span> merely mirror it. Observe that your definition of 'non-trivial' may not be equivalent to ours!</li></ul>

<p>Leave your code in the <span class="code">tictactoe</span> directory and include it with your archive submission.</p>

<h4>Further Work</h4>

<p><span class="emph">These are more time-consuming exercises. Complete them only if you have time.</span></p>

<p>Meta-tic-tac-toe is a variation on tic-tac-toe played on a 3x3 grid of tic-tac-toe boards. The rules are as follows:</p>

<ul><li>This is a two-player game.</li>
<li>The X player always receives priority first.</li>
<li>Every turn, the player with priority places one symbol on an open square on the active board. The active board is then switched to the board corresponding to the square on which the symbol has placed.</li>
<ul><li>In other words, if the O player places an O on the top-right square of some board, then the top-right board becomes active.</li></ul>
<li>Priority is passed to the other player after the player with priority has moved and the active board has switched.</li>
<li>If the active board has no legal moves, or no moves have yet been made, the player with priority may play on any board.</li>
<li>If a player achieves three in a row on an individual board, the board itself becomes marked with that player's symbol. Moves may still be made on a board that has been thusly marked, but additional three-in-a-rows by either player will have no effect.</li>
<li>If three boards in a row have been marked with a single player's symbol, that player wins the game.</li>
<li>If no legal moves remain, the winner is the player that has successfully marked more boards. If neither player has marked more boards than the other in this situation, then the game is a draw.</li></ul>

<p><div class="points hard">3</div>Implement this game in a new folder <span class="code">metatictactoe</span>. Include this folder with your archive submission. If you did a good job with the tic-tac-toe exercise, you should be able to reuse some code.</p>

<p><div class="points hard">5</div>If you want, you can do another board game of your choice, either instead of or in addition to the above; checkers might be a good choice, since the rules are reasonably simple.</p>

<hr />

<h2>Appendix: <span class="code">struct</span> usage in C</h2>

<p>C++ inherits structs from C, and additionally allows a struct defined as <span class="code">struct Foo</span> to be instantiated as type <span class="code">Foo</span>. C does not allow this: the correct typename in C is <span class="code">struct Foo</span>.</p>

<p>It's tedious to type <span class="code">struct Foo</span> each time you want to instantiate a Foo, so usually C programmers will use a <span class="code">typedef</span> to allow them to use a shorter name. (The <span class="code">typedef</span> keyword exists in C++ as well, and is commonly used to shorten frequently used, otherwise lengthy template class names.)</p>

<p>If you're looking at C code, or C++ code written by C veterans, you'll sometimes see one of the following idioms:</p>

<div class="codebox">
    <pre><code class="prettyprint">struct foo
{
    
    ...
    
};

...

typedef struct foo Foo;

...

Foo x; /* this is valid */
</code></pre>
</div>

<div class="codebox">
    <pre><code class="prettyprint">typedef struct foo /* can optionally omit the name here */
{
    
    ...
    
} Foo;

...

Foo x; /* this is also valid */
</code></pre>
</div>

<p>Both are valid, but unnecessary, C++. However, they're worth keeping in mind when moving from C++ to C, as you may in later terms.</p>

<hr />

<p>If you have any questions about this week's assignment, please contact &lt;cs2-tas@ugcs.caltech.edu&gt;, or show up at any TA's office hours.</p>

</div>

</body>

</html>
